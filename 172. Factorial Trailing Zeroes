public int trailingZeroes(int n) {
        if(n <= 0) return 0;
        int sum = 0;
        
        while(n != 0){
            sum += n/5;
            n /= 5;
        }
        return sum;
    }
    
    朴素解法：
首先求出n!，然后计算末尾0的个数。（重复÷10，直到余数非0）

该解法在输入的数字稍大时就会导致阶乘得数溢出，不足取。

O（logn）解法：
一个更聪明的解法是：考虑n!的质数因子。后缀0总是由质因子2和质因子5相乘得来的。
如果我们可以计数2和5的个数，问题就解决了。考虑下面的例子：
n = 5: 5!的质因子中 (2 * 2 * 2 * 3 * 5)包含一个5和三个2。因而后缀0的个数是1。
n = 11: 11!的质因子中(2^8 * 3^4 * 5^2 * 7)包含两个5和三个2。于是后缀0的个数就是2。
我们很容易观察到质因子中2的个数总是大于等于5的个数。因此只要计数5的个数就可以了。
那么怎样计算n!的质因子中所有5的个数呢？一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。
除此之外，还有一件事情要考虑。诸如25，125之类的数字有不止一个5。
25! = 有6个5(有5个5来自其中的5, 10, 15, 20, 25， 另外还有1个5来自25=(5*5)的另外一个5）
最后的解法就是对n/5+n/25+n/125+…+进行求和，当n小于分母的时候，停止。
分母依次为5^1, 5^2, 5^2… 这样的话在计算5^2的时候，能被25整除的数里面的两个5，
其中一个已经在5^1中计算过了。所以5^2直接加到count上。
